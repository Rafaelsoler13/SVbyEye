#' Read self-alignments as \code{\link{GRanges-class}} object.
#' 
#' This function reads FASTA self-alignments generated by 'nucmer' or 'minimap2' aligner.
#' This function considers proximal (leftmost) duplication as a query(s1)
#' and corresponding distal (rightmost) duplication as a target (s2)
#'
#' @param aln.coords A path to a file containing self-alignment coordinates.
#' @param format Define format of the input alignment coordinates as either 'nucmer' or minimap2 'mm2', [default: 'nucmer']
#' @param min.align.len 
#' @param min.align.dist Keep alignment pairs with this or larger distance from each other.
#' @param collapse.overlaps Set to \code{TRUE} to merge overlapping pair of alignments with the same relative orientation.
#' @param break.paf.aln Set to \code{TRUE} in order to split CIGAR string at insertions and deletions.
#' @inheritParams breakPafAlignment
#' @return A \code{list} of \code{\link{GRanges-class}} objects.
#' @importFrom scales comma
#' @importFrom S4Vectors subjectHits queryHits endoapply
#' @import GenomicRanges
#' @author David Porubsky
#' @export
readSelfAlignments <- function(aln.coords=NULL, format='nucmer', min.align.len=1000, min.align.dist=1000, collapse.overlaps=TRUE, break.paf.aln=TRUE, min.deletion.size = 1000, min.insertion.size = 1000) {
  ## Check if the submitted file exists
  if (!nchar(aln.coords) > 0 | !file.exists(aln.coords)) {
    stop("Submitted file in 'aln.coords' does not exists !!!")
  }
  
  ## Data input ##
  ################
  if (format == 'nucmer') {
    ## Read in coordinates from nucmer output
    coords <- utils::read.table(aln.coords, skip=5, stringsAsFactors = FALSE)
    coords.df <- data.frame(s1.start=coords$V1,
                            s1.end=coords$V2,
                            s2.start=coords$V4,
                            s2.end=coords$V5,
                            s1.width=abs(coords$V1 - coords$V2),
                            s2.width=abs(coords$V4 - coords$V5),
                            s1.id=coords$V12,
                            s2.id=coords$V12, 
                            stringsAsFactors = FALSE)
  } else if (format == 'mm2') {
    ## Read in coordinates from minimap2 output
    paf.data <- readPaf(paf.file = aln.coords, restrict.paf.tags = 'cg')
    ## Due to the minimap2 self-alignment redundancy keep only alignments where query start is smaller than target start
    paf.data <- paf.data[paf.data$q.start < paf.data$t.start,]
    ## Break paf alignments
    if (break.paf.aln) {
      paf.data <- breakPaf(paf.table = paf.data, min.deletion.size = min.deletion.size, min.insertion.size = min.insertion.size, report.sv = TRUE)
      paf.data.sv <- paf.data$SVs
      paf.data <- paf.data$M
    } else {
      paf.data.sv <- NULL
    } 
    coords.df <- data.frame(s1.start=paf.data$q.start,
                            s1.end=paf.data$q.end,
                            s2.start=paf.data$t.start,
                            s2.end=paf.data$t.end,
                            s1.width=paf.data$aln.len,
                            s2.width=paf.data$aln.len,
                            s1.id=paf.data$q.name,
                            s2.id=paf.data$t.name,
                            stringsAsFactors = FALSE)
    
    ## Flip start and end for reverse oriented alignments
    coords.df[paf.data$strand == '-',] <- transform(coords.df[paf.data$strand == '-',], 's2.start' = s2.end, 's2.end' = s2.start)
  }
  
  ## Data transformations ##
  ##########################
  ## Add alignment directionality
  coords.df$dir <- 'rev'
  forw.mask <- (coords.df$s1.start < coords.df$s1.end) & (coords.df$s2.start < coords.df$s2.end)
  coords.df$dir[forw.mask] <- 'forw'
  
  ## Make sure s1 coordinates are always smaller than s2 coordinates
  toFlip <- which(pmin(coords.df$s1.start, coords.df$s1.end) > pmax(coords.df$s2.start, coords.df$s2.end))
  coords.df[toFlip,] <- transform(coords.df[toFlip,], 's1.start' = s2.start, 's1.end' = s2.end, 's2.start' = s1.start, 's2.end' = s1.end)
  
  ## Get distance between alignments
  coords.df <- transform(coords.df, dist = pmin(s2.start, s2.end) - pmax(s1.start, s1.end))
  
  ## Data filtering ##
  ####################
  ## Keep diagonals (self-alignments) for export
  # diagonals.df <- coords.df[coords.df$s1.start == coords.df$s2.start & coords.df$s1.end == coords.df$s2.end,]
  # if (nrow(diagonals.df) > 0) {
  #   diagonals.gr <- GenomicRanges::makeGRangesFromDataFrame(diagonals.df, seqnames.field = 's1.id', start.field = 's1.start', end.field = 's1.end')
  #   names(diagonals.gr) <- NULL
  # } else {
  #   diagonals.gr <- NULL
  # }  
  ## Remove diagonals (self-alignments) with the same start and end position
  coords.df <- coords.df[!(coords.df$s1.start == coords.df$s2.start & coords.df$s1.end == coords.df$s2.end),]
  ## Filter by alignment length
  if (min.align.len > 0) {
    coords.df <- coords.df[coords.df$s1.width >= min.align.len & coords.df$s2.width >= min.align.len,]
  }
  ## Remove duplicated ranges
  #paste0(coords.df$s1.start, coords.df$s1.end) %in% paste0(coords.df$s2.start, coords.df$s2.end)
  xmin <- apply(coords.df[,c('s1.start', 's1.end', 's2.start', 's2.end')], 1, min)
  xmax <- apply(coords.df[,c('s1.start', 's1.end', 's2.start', 's2.end')], 1, max)
  coords.df <- coords.df[!duplicated(paste(xmin, xmax, sep = '_')),]
  ## Filter by alignment distance
  if (min.align.dist > 0) {
    coords.df <- coords.df[coords.df$dist >= min.align.dist,]
  }
  
  ## Collapse overlapping alignments with the same directionality ##
  ##################################################################
  ## Convert alignments to Genomic ranges
  s1.gr <- GenomicRanges::GRanges(seqnames = 's1', ranges = IRanges::IRanges(start=pmin(coords.df$s1.start,coords.df$s1.end), end=pmax(coords.df$s1.start,coords.df$s1.end)), dir=coords.df$dir)
  s2.gr <- GenomicRanges::GRanges(seqnames = 's2', ranges = IRanges::IRanges(start=pmin(coords.df$s2.start,coords.df$s2.end), end=pmax(coords.df$s2.start,coords.df$s2.end)), dir=coords.df$dir)
  ## Order by S1 coords
  ord <- GenomicRanges::order(s1.gr)
  s1.gr <- s1.gr[ord]
  s2.gr <- s2.gr[ord]
  
  if (collapse.overlaps) {
    ## Get self-alignments
    hits1 <- IRanges::findOverlaps(s1.gr, drop.self=TRUE)
    hits2 <- IRanges::findOverlaps(s2.gr, drop.self=TRUE)
    ## Keep unique overlap pairs
    mask1 <- !duplicated(paste0(pmin(S4Vectors::queryHits(hits1), S4Vectors::subjectHits(hits1)), pmax(S4Vectors::queryHits(hits1), S4Vectors::subjectHits(hits1))))
    hits1 <- hits1[mask1]
    mask2 <- !duplicated(paste0(pmin(S4Vectors::queryHits(hits2), S4Vectors::subjectHits(hits2)), pmax(S4Vectors::queryHits(hits2), S4Vectors::subjectHits(hits2))))
    hits2 <- hits2[mask2]
    ## Keep pairs overlapping each other
    mask1 <- paste0(S4Vectors::queryHits(hits1), S4Vectors::subjectHits(hits1)) %in% paste0(S4Vectors::queryHits(hits2), S4Vectors::subjectHits(hits2))
    mask2 <- paste0(S4Vectors::queryHits(hits2), S4Vectors::subjectHits(hits2)) %in% paste0(S4Vectors::queryHits(hits1), S4Vectors::subjectHits(hits1))
    hits1 <- hits1[mask1]
    hits2 <- hits2[mask2]
    ## Keep pairs having the same dir
    mask <- s1.gr$dir[S4Vectors::queryHits(hits1)] == s1.gr$dir[S4Vectors::subjectHits(hits1)] & s2.gr$dir[S4Vectors::queryHits(hits2)] == s2.gr$dir[S4Vectors::subjectHits(hits2)]
    hits1 <- hits1[mask]
    hits2 <- hits2[mask]
    
    #if (length(hits1) > 1 & length(hits2) > 1) {
    while (length(hits1) > 1 & length(hits2) > 1) {
      ## Get groups alignments overlapping each other
      groups <- list()
      #for (i in seq_along(hits1)) {
      for (i in order(S4Vectors::subjectHits(hits1))) {
        pair <- hits1[i]
        pair <- c(S4Vectors::queryHits(pair), S4Vectors::subjectHits(pair))
        if (length(groups) == 0) {
          groups[[length(groups) + 1]] <- pair
          group.id <- 1
        } else {
          if (any(pair %in% groups[[group.id]])) {
            groups[[group.id]] <- unique(c(groups[[group.id]], pair))
          } else {
            group.id <- group.id + 1
            groups[[group.id]] <- pair
          }
        }
      }
      ## Get alignment groups
      grp <- unlist(groups)
      names(grp) <- rep(1:length(groups), times=lengths(groups))
      ## Assign alignment groups to GRanges
      s1.gr$group <- 0
      s2.gr$group <- 0
      s1.gr$group[grp] <- names(grp)
      s2.gr$group[grp] <- names(grp)
      ## Collapse ranges from the same group
      ## alignment1
      s1.collapse.grl <- GenomicRanges::split(s1.gr[s1.gr$group > 0], s1.gr$group[s1.gr$group > 0])
      s1.collapse.gr <- unlist(S4Vectors::endoapply(s1.collapse.grl, range))
      s1.collapse.gr$dir <- sapply(s1.collapse.grl, function(x) unique(x$dir))
      s1.collapse.gr$group <- unique(s1.gr$group[s1.gr$group > 0])
      names(s1.collapse.gr) <- NULL
      ## alignment2
      s2.collapse.grl <- split(s2.gr[s1.gr$group > 0], s2.gr$group[s2.gr$group > 0])
      s2.collapse.gr <- unlist(S4Vectors::endoapply(s2.collapse.grl, range))
      s2.collapse.gr$dir <- sapply(s2.collapse.grl, function(x) unique(x$dir))
      s2.collapse.gr$group <- unique(s2.gr$group[s2.gr$group > 0])
      names(s2.collapse.gr) <- NULL
      ## Replace collapsed ranges
      s1.gr <- c(s1.gr[s1.gr$group == 0], s1.collapse.gr)
      s2.gr <- c(s2.gr[s2.gr$group == 0], s2.collapse.gr)
      
      ## Recalculate self-alignments
      hits1 <- IRanges::findOverlaps(s1.gr, drop.self=TRUE)
      hits2 <- IRanges::findOverlaps(s2.gr, drop.self=TRUE)
      ## Keep unique overlap pairs
      mask1 <- !duplicated(paste0(pmin(queryHits(hits1), subjectHits(hits1)), pmax(queryHits(hits1), subjectHits(hits1))))
      hits1 <- hits1[mask1]
      mask2 <- !duplicated(paste0(pmin(queryHits(hits2), subjectHits(hits2)), pmax(queryHits(hits2), subjectHits(hits2))))
      hits2 <- hits2[mask2]
      ## Keep pairs overlapping each other
      mask1 <- paste0(queryHits(hits1), subjectHits(hits1)) %in% paste0(queryHits(hits2), subjectHits(hits2))
      mask2 <- paste0(queryHits(hits2), subjectHits(hits2)) %in% paste0(queryHits(hits1), subjectHits(hits1))
      hits1 <- hits1[mask1]
      hits2 <- hits2[mask2]
      ## Keep pairs having the same dir
      mask <- s1.gr$dir[queryHits(hits1)] == s1.gr$dir[subjectHits(hits1)] & s2.gr$dir[queryHits(hits2)] == s2.gr$dir[subjectHits(hits2)]
      hits1 <- hits1[mask]
      hits2 <- hits2[mask]
    }
  }  
  ## Remove remaining self-overlapping ranges
  if (min.align.dist > 0) {
    s2.copy.gr <- s2.gr
    seqlevels(s2.copy.gr) <- 's1'
    mask <- which(IRanges::distance(s1.gr, s2.copy.gr) == 0)
    if (length(mask) > 0) {
      s1.gr <- s1.gr[-mask]
      s2.gr <- s2.gr[-mask]
    }    
  }
  
  ## Prepare object of self-alignments for export
  if (length(s1.gr) > 0 & length(s2.gr) > 0) {
    self.gr <- GenomicRanges::GRanges(seqnames=unique(coords.df$s1.id), ranges=ranges(s1.gr[,0]))
    #self.gr$s2 <- s2.gr[,0]
    self.gr$s2 <- GenomicRanges::GRanges(seqnames=unique(coords.df$s1.id), ranges=ranges(s2.gr[,0]))
    strand(self.gr) <- '+'
    strand(self.gr$s2) <- ifelse(s1.gr$dir == 'forw', '+', '-')
  } else {
    self.gr <- NULL
  } 
  ## Prepare reported SVs for export
  if (format == 'mm2') {
    if (nrow(paf.data.sv) > 0) {
      sv.gr <- GenomicRanges::GRanges(seqnames=paf.data.sv$q.name, ranges=IRanges(start=paf.data.sv$q.start, end=paf.data.sv$q.end), strand = strand('*'))
      sv.gr$s2 <- GenomicRanges::GRanges(seqnames=paf.data.sv$t.name, ranges=IRanges(start=paf.data.sv$t.start, end=paf.data.sv$t.end), strand = strand('*'))
      sv.gr$sv.type <- gsub(paf.data.sv$cg, pattern = '\\d+', replacement = '')
      sv.gr$sv.size <- gsub(paf.data.sv$cg, pattern = '[A-Z,=]', replacement = '', ignore.case = TRUE)
    }  
  } else {
    sv.gr <- GenomicRanges::GRanges()
  }
  ## Return self-alignments
  return(list('SelfAlnPairs' = self.gr, 'SVs' = sv.gr))
}  
  
    